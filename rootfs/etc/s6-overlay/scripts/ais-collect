#!/command/with-contenv bash
#shellcheck shell=bash
#shellcheck disable=SC2016,SC2068,SC2076,SC2086,SC2015,SC2164,SC1090,SC1091,SC2154

# AIS-Collect:
# read AIS data from a AIS-Catcher web service and
# create and maintain a database with this data
#---------------------------------------------------------------------------------------------
# Copyright (C) 2022-2025, Ramon F. Kolb (kx1t)
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program.
# If not, see <https://www.gnu.org/licenses/>.
#---------------------------------------------------------------------------------------------

source /scripts/common

"${s6wrap[@]}" echo "[INFO] Started as an s6 service"
if chk_enabled "$DEBUG"; then "${s6wrap[@]}" echo "[INFO] DEBUG=ON"; else "${s6wrap[@]}" echo "[INFO] DEBUG=OFF"; fi

renice -n 10 -p $$ >/dev/null 2>&1

CHECK_INTERVAL="${CHECK_INTERVAL:-30}"
VESSELDBFILE="${VESSELDBFILE:-/data/vessel.db}"
MIN_MSG_COUNT="${MIN_MSG_COUNT:-10}"
[[ "${AIS_URL:0:4}" != "http" ]] && AIS_URL="http://${AIS_URL}"
[[ "${AIS_URL: -4}" != "json" ]] && AIS_URL="${AIS_URL}/ships.json"

RUNS_BEFORE_RESTART="$((3 * 60 * 60 / CHECK_INTERVAL))"

for (( loops=0; loops<RUNS_BEFORE_RESTART; loops++ )); do

    if chk_enabled "$DEBUG"; then "${s6wrap[@]}" echo "[DEBUG] starting run"; fi

    # lock the database:
    source "/usr/share/vesselalert/vesseldb_lock"

    # First read the existing entries in from file
    source "/usr/share/vesselalert/load_databases"

    # Now update it with the ones from the AIS_URL website.
    # Read VESSELS from the AIS_URL:
    ships_json="$(curl --compressed -sSL "$AIS_URL")"

    # check if ships_json is empty. If so, continue the loop but don't count against loop counter
    if [[ -z "$ships_json" ]]; then
        "${s6wrap[@]}" echo "[WARNING] $AIS_URL did not return a valid ships.json object. This may be a start-up fluke, but if the message continues to appear, please check your ships.json data source!"
        rm -f "$VESSELDBLOCK"
        sleep $CHECK_INTERVAL
        (( loops-- ))
        continue
    fi

    eval "$(nice -n 20 jq -r '.ships[] | .mmsi as $mmsi | to_entries[] | @sh "VESSELS[\("\($mmsi):\(.key)")]=\(.value)"' <<< "$ships_json" )"
    # Add a last_updated field to all the newly entered or updated vessels:
    eval "$(nice -n 20 jq -r '.ships[] | .mmsi as $mmsi | to_entries[] | "VESSELS[\("\($mmsi):")"' <<< "$ships_json" | sort -u | sed 's/:/:last_updated\]='"$(date +%s)"'/g')"

    # create the indices
    readarray -t VESSEL_INDEX <<< "$({ for vessel in "${!VESSELS[@]}"; do echo "${vessel%%:*}"; done; } | sort -un)"
    readarray -t KEY_INDEX <<< "$({ for vessel in "${!VESSELS[@]}"; do echo "${vessel#*:}"; done; } | sort -u )"

    # Calculate ship's beam (=width) and length, if not already available:
    for vessel in "${VESSEL_INDEX[@]}"; do
        if [[ -z "${VESSELS[${vessel}:beam]}" ]] \
            && [[ -n "${VESSELS[${vessel}:to_starboard]}" ]] \
            && [[ "${VESSELS[${vessel}:to_starboard]}" != "null" ]] \
            && [[ -n "${VESSELS[${vessel}:to_port]}" ]] \
            && [[ "${VESSELS[${vessel}:to_port]}" != "null" ]]; then
                VESSELS[${vessel}:beam]="$((${VESSELS[${vessel}:to_starboard]} + ${VESSELS[${vessel}:to_port]}))"
                VESSELS[${vessel}:beam_unit]="m"
        fi
        if [[ -z "${VESSELS[${vessel}:length]}" ]] \
            && [[ -n "${VESSELS[${vessel}:to_bow]}" ]] \
            && [[ "${VESSELS[${vessel}:to_bow]}" != "null" ]] \
            && [[ -n "${VESSELS[${vessel}:to_stern]}" ]] \
            && [[ "${VESSELS[${vessel}:to_stern]}" != "null" ]]; then
                VESSELS[${vessel}:length]="$((${VESSELS[${vessel}:to_bow]} + ${VESSELS[${vessel}:to_stern]} ))"
                VESSELS[${vessel}:length_unit]="m"
        fi
    done

    # Write back to file
    source "/usr/share/vesselalert/save_databases"

    # Clean up memory; arrays will be re-read next turn
    unset KEY_INDEX VESSEL_INDEX VESSELS SHIPTYPE SHIPSTATUS COUNTRY 

    rm -f "$VESSELDBLOCK"
    if chk_enabled "$DEBUG"; then "${s6wrap[@]}" echo "[DEBUG] finished with run"; fi
    sleep $CHECK_INTERVAL

done
"${s6wrap[@]}" echo "[INFO] restarting $0 to clean up memory"
